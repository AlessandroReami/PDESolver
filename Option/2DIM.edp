// Parameters
int m = 30; int j = 100; real sigx = 0.3; real sigy = 0.3; real rho = 0.3; real r = 0.05; real dt = 0.01;

// Input Parameters
// string payoff = getARGV("-payoff_type", "PUT_MAX");
// if (payoff == "PUT_MAX")
//  Vh u = max(K-max(x,y),0.);
// else if (payoff == "PUT_MIN")
//  Vh u = max(K-(x+y), 0.);
// else if (payoff == "PUT_AVERAGE")
//  Vh u = max(K-min(x,y),0.);
// end if

// real K= getARGV("-strike", 40);
// real[int] domain(2) = getARGV("-domain");
// int L = domain[0];
// int LL = domain[1];
// string exercise = getARGV("-exercise_type");

real K= 40;
int L = 100;
int LL = 100;




real rhohat=2*rho/(1+rho^2);

// Mesh
mesh th = square(m, m, [L*x, LL*y]);

// Fespace
fespace Vh(th, P1);
Vh u = max(K-max(x,y),0.);
Vh xveloc, yveloc, v, uold;

// Time loop
for (int n = 0; n*dt <= 1.0; n++){
    // Mesh adaptation
    if (j > 20){
        th = adaptmesh(th, u, verbosity=1, abserror=1, nbjacoby=2,
        err=0.001, nbvx=5000, omega=1.8, ratio=1.8, nbsmooth=3,
        splitpbedge=1, maxsubdiv=5, rescaling=1);
        j = 0;
        xveloc = -x*r + x*sigx^2 + x*rhohat*sigx*sigy/2;
        yveloc = -y*r + y*sigy^2 + y*rhohat*sigx*sigy/2;
        u = u;
    }

    // Update
    uold = u;

    // Solve
    solve eq1(u, v, init=j, solver=LU)
        = int2d(th)(
              u*v*(r+1/dt)
            + dx(u)*dx(v)*(x*sigx)^2/2
            + dy(u)*dy(v)*(y*sigy)^2/2
            + (dy(u)*dx(v) + dx(u)*dy(v))*rhohat*sigx*sigy*x*y/2
        )
        - int2d(th)(
              v*convect([xveloc, yveloc], dt, uold)/dt
        )
        + on(2, 3, u=0)
        ;

    // Update
    j = j+1;
};

// Plot
plot(u, wait=true, value=true);
